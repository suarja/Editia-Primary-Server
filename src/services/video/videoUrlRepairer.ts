/**
 * Service for repairing video URLs that may be incorrectly generated by AI
 * at different stages of the video generation pipeline
 */
export class VideoUrlRepairer {
  private originalVideos: any[];
  private urlMap: Map<string, string>; // videoId -> correctUrl
  private patternMap: Map<string, string>; // filename -> correctUrl
  private corrections: Array<{
    step: string;
    incorrect: string;
    corrected: string;
    method: "videoId" | "filename" | "none";
  }> = [];

  constructor(originalVideos: any[]) {
    this.originalVideos = originalVideos;
    this.urlMap = new Map(originalVideos.map((v) => [v.id, v.url]));
    this.patternMap = new Map(
      originalVideos.map((v) => [
        v.url.split("/").pop(), // nom du fichier
        v.url,
      ])
    );
  }

  /**
   * Repair a potentially incorrect URL using various strategies
   * @param incorrectUrl The URL that may be incorrect
   * @param videoId Optional video ID for direct mapping
   * @param step The step in the pipeline where this repair is happening
   * @returns The corrected URL or the original if no repair needed
   */
  repairUrl(
    incorrectUrl: string,
    videoId?: string,
    step: string = "unknown"
  ): string {
    // 1. If URL is already correct, return as-is
    if (this.originalVideos.some((v) => v.url === incorrectUrl)) {
      return incorrectUrl;
    }

    let correctUrl = null;
    let method: "videoId" | "filename" | "none" = "none";

    // 2. If we have a videoId, use direct mapping
    if (videoId && this.urlMap.has(videoId)) {
      correctUrl = this.urlMap.get(videoId);
      method = "videoId";
    }

    // 3. Otherwise, try matching by filename
    if (!correctUrl) {
      const filename = incorrectUrl.split("/").pop();
      if (filename && this.patternMap.has(filename)) {
        correctUrl = this.patternMap.get(filename);
        method = "filename";
      }
    }

    // 4. Log correction and return
    if (correctUrl && correctUrl !== incorrectUrl) {
      this.corrections.push({
        step,
        incorrect: incorrectUrl,
        corrected: correctUrl,
        method,
      });

      console.warn(`üîß R√©paration URL (${step}):`, {
        incorrect: incorrectUrl,
        corrected: correctUrl,
        method,
        videoId: videoId || "N/A",
      });

      return correctUrl;
    }

    // 5. No repair possible, log warning
    if (incorrectUrl !== correctUrl) {
      console.warn(`‚ö†Ô∏è Impossible de r√©parer l'URL (${step}):`, {
        incorrectUrl,
        availableUrls: this.originalVideos.map((v) => v.url),
        videoId: videoId || "N/A",
      });
    }

    return incorrectUrl;
  }

  /**
   * Repair URLs in a scene plan object
   * @param scenePlan The scene plan from planVideoStructure
   */
  repairScenePlan(scenePlan: any): void {
    if (!scenePlan.scenes || !Array.isArray(scenePlan.scenes)) {
      return;
    }

    scenePlan.scenes.forEach((scene: any, index: number) => {
      if (scene.video_asset?.url) {
        scene.video_asset.url = this.repairUrl(
          scene.video_asset.url,
          scene.video_asset.id,
          `plan_structure_scene_${index}`
        );
      }
    });
  }

  /**
   * Repair URLs in a Creatomate template
   * @param template The template from generateTemplate
   */
  repairTemplate(template: any): void {
    if (!template.elements || !Array.isArray(template.elements)) {
      return;
    }

    template.elements.forEach((composition: any, compIndex: number) => {
      if (composition.elements && Array.isArray(composition.elements)) {
        composition.elements.forEach((element: any, elemIndex: number) => {
          if (element.type === "video" && element.source) {
            element.source = this.repairUrl(
              element.source,
              undefined, // No videoId available at this stage
              `generate_template_comp_${compIndex}_elem_${elemIndex}`
            );
          }
        });
      }
    });
  }

  /**
   * Validate that all URLs in the template are correct
   * @param template The template to validate
   * @throws Error if any invalid URLs are found
   */
  validateTemplate(template: any): void {
    const validUrls = new Set(this.originalVideos.map((v) => v.url));
    const invalidUrls: string[] = [];

    template.elements?.forEach((composition: any, compIndex: number) => {
      composition.elements?.forEach((element: any, elemIndex: number) => {
        if (element.type === "video" && element.source) {
          if (!validUrls.has(element.source)) {
            invalidUrls.push(
              `comp_${compIndex}_elem_${elemIndex}: ${element.source}`
            );
          }
        }
      });
    });

    if (invalidUrls.length > 0) {
      throw new Error(
        `URLs invalides d√©tect√©es dans le template: ${invalidUrls.join(", ")}`
      );
    }

    console.log("‚úÖ Toutes les URLs du template sont valides");
  }

  /**
   * Get all corrections made during the repair process
   * @returns Array of correction objects
   */
  getCorrections() {
    return this.corrections;
  }

  /**
   * Get a summary of corrections made
   * @returns Summary object with counts and details
   */
  getRepairSummary() {
    const summary = {
      totalCorrections: this.corrections.length,
      byStep: {} as Record<string, number>,
      byMethod: {} as Record<string, number>,
    };

    this.corrections.forEach((correction) => {
      // Count by step
      if (!summary.byStep[correction.step]) {
        summary.byStep[correction.step] = 0;
      }
      summary.byStep[correction.step] =
        (summary.byStep[correction.step] || 0) + 1;

      // Count by method
      if (!summary.byMethod[correction.method]) {
        summary.byMethod[correction.method] = 0;
      }
      summary.byMethod[correction.method] =
        (summary.byMethod[correction.method] || 0) + 1;
    });

    return summary;
  }
}
