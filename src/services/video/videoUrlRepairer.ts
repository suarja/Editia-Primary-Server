import { ScenePlan, ScenePlanSchema, ValidatedVideo } from "../../types/video";
import winston from "winston";
import OpenAI from "openai";
import { createOpenAIClient } from "../../config/openai";
import { zodTextFormat } from "openai/helpers/zod";

export class ScenePlanRepairFailedError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ScenePlanRepairFailedError";
  }
}

/**
 * Service for repairing video URLs that may be incorrectly generated by AI
 * at different stages of the video generation pipeline
 */
export class VideoUrlRepairer {
  private originalVideos: ValidatedVideo[];
  private urlMap: Map<string, string>; // videoId -> correctUrl
  private patternMap: Map<string, string>; // filename -> correctUrl
  private openai: OpenAI;
  private corrections: Array<{
    step: string;
    incorrect: string;
    corrected: string;
    method: "videoId" | "filename" | "ai_judge" | "none";
  }> = [];
  private logger: winston.Logger;

  constructor(originalVideos: ValidatedVideo[], logger: winston.Logger) {
    this.originalVideos = originalVideos;
    this.openai = createOpenAIClient();
    this.urlMap = new Map(
      originalVideos.map((v) => [v.id, v.upload_url || ""])
    );
    this.patternMap = new Map(
      originalVideos.map((v) => [
        (v.upload_url || "").split("/").pop() as string, // nom du fichier
        v.upload_url || "",
      ])
    );
    this.logger = logger;
  }

  async repairScenePlanWithAI(
    scenePlan: ScenePlan,
    logger: winston.Logger,
    maxRetries = 2
  ): Promise<ScenePlan> {
    let lastError: any = null;
    for (let i = 0; i <= maxRetries; i++) {
      try {
        logger.info(
          `ü§ñ Calling AI Judge for scene plan repair. Attempt ${i + 1}`
        );
        const repairedPlan = await this.callAIEnhancer(scenePlan, logger);

        // Validate all URLs in the repaired plan deterministically
        this.validateScenePlan(repairedPlan);
        logger.info(
          `‚úÖ AI Judge successfully repaired and validated the scene plan.`
        );
        return repairedPlan;
      } catch (error) {
        lastError = error;
        logger.warn(
          `‚ö†Ô∏è AI Judge repair attempt ${i + 1} failed: ${
            error instanceof Error ? error.message : "Unknown error"
          }`
        );
        if (i === maxRetries) {
          logger.error(
            `‚ùå AI Judge failed to repair the scene plan after ${
              maxRetries + 1
            } attempts.`
          );
          throw new ScenePlanRepairFailedError(
            `Failed to repair scene plan with AI after ${
              maxRetries + 1
            } attempts. Last error: ${lastError}`
          );
        }
      }
    }
    // This part should be unreachable, but typescript needs a return path.
    throw new ScenePlanRepairFailedError(
      `Exited repair loop unexpectedly. Last error: ${lastError}`
    );
  }

  private async callAIEnhancer(
    scenePlan: ScenePlan,
    logger: winston.Logger
  ): Promise<ScenePlan> {
    const systemPrompt = `You are an AI Video Production Assistant. Your task is to review a "scene plan" and ensure every video asset assigned to a scene is 100% correct and valid based on a provided list of "Available Videos". You must also intelligently select video segments using analysis data if available.

    CRITICAL VALIDATION RULES:
    1.  **URL and ID Correction**: For each scene, find the corresponding video in "Available Videos" and ensure the \`id\`, \`url\`, and \`title\` in the \`video_asset\` are EXACTLY what is in the "Available Videos" list. The AI that created the plan might have hallucinated or used incorrect user IDs in the URLs.
    2.  **Segment Selection (Trimming)**:
        *   If a video in "Available Videos" has \`analysis_data\`, inspect its \`segments\`.
        *   Find the best segment matching the scene's \`script_text\`.
        *   If a good segment is found, use its timestamps to set \`trim_start\` and \`trim_duration\`.
        *   If no \`analysis_data\` or relevant segment exists, DO NOT include \`trim_start\` or \`trim_duration\`.
    3.  **Return Full Structure**: You MUST return the complete, corrected JSON object matching the ScenePlan schema. Do not omit any fields.`;

    const userPrompt = `Please review and correct the following scene plan.

    **Scene Plan to Correct:**
    ${JSON.stringify(scenePlan, null, 2)}

    **Available Videos (Source of Truth):**
    ${JSON.stringify(this.originalVideos, null, 2)}

    Apply all validation and enhancement rules and return the full, corrected ScenePlan JSON object.`;

    const response = await this.openai.responses.parse({
      model: "gpt-4o",
      input: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt },
      ],
      text: {
        format: zodTextFormat(ScenePlanSchema, "scene_plan"),
      },
    });

    if (!response.output_parsed) {
      throw new Error(
        `AI enhancer failed to return a valid scene plan. Error: ${response.error?.message}`
      );
    }
    const newScenePlan = response.output_parsed;
    // Log the corrections made by the AI judge
    scenePlan.scenes.forEach((originalScene, index) => {
      const repairedScene = newScenePlan.scenes[
        index
      ] as ScenePlan["scenes"][number];
      if (originalScene.video_asset.url !== repairedScene.video_asset.url) {
        this.corrections.push({
          step: `ai_judge_scene_${index}`,
          incorrect: originalScene.video_asset.url,
          corrected: repairedScene.video_asset.url,
          method: "ai_judge",
        });
      }
    });

    return response.output_parsed;
  }

  /**
   * Validates a scene plan against the original video list.
   * Throws an error if any URL is invalid.
   */
  validateScenePlan(scenePlan: ScenePlan): void {
    const validUrls = new Set(this.originalVideos.map((v) => v.upload_url));
    const invalidAssets: string[] = [];

    scenePlan.scenes.forEach((scene, index) => {
      const url = scene.video_asset.url;
      if (!validUrls.has(url)) {
        invalidAssets.push(`Scene ${index} (URL: ${url})`);
      }
    });

    if (invalidAssets.length > 0) {
      throw new Error(
        `Deterministic validation failed. Invalid video assets found in scene plan: ${invalidAssets.join(
          ", "
        )}`
      );
    }
  }

  /**
   * Repair a potentially incorrect URL using various strategies
   * @param incorrectUrl The URL that may be incorrect
   * @param videoId Optional video ID for direct mapping
   * @param step The step in the pipeline where this repair is happening
   * @returns The corrected URL or the original if no repair needed
   */
  repairUrl(
    incorrectUrl: string,
    videoId?: string,
    step: string = "unknown"
  ): string {
    // 1. If URL is already correct, return as-is
    if (this.originalVideos.some((v) => v.upload_url === incorrectUrl)) {
      return incorrectUrl;
    }

    let correctUrl = null;
    let method: "videoId" | "filename" | "none" = "none";

    // 2. If we have a videoId, use direct mapping
    if (videoId && this.urlMap.has(videoId)) {
      correctUrl = this.urlMap.get(videoId);
      method = "videoId";
    }

    // 3. Otherwise, try matching by filename
    if (!correctUrl) {
      const filename = incorrectUrl.split("/").pop();
      if (filename && this.patternMap.has(filename)) {
        correctUrl = this.patternMap.get(filename);
        method = "filename";
      }
    }

    // 4. Log correction and return
    if (correctUrl && correctUrl !== incorrectUrl) {
      this.corrections.push({
        step,
        incorrect: incorrectUrl,
        corrected: correctUrl,
        method,
      });

      console.warn(`üîß R√©paration URL (${step}):`, {
        incorrect: incorrectUrl,
        corrected: correctUrl,
        method,
        videoId: videoId || "N/A",
      });

      return correctUrl;
    }

    // 5. No repair possible, log warning
    if (incorrectUrl !== correctUrl) {
      console.warn(`‚ö†Ô∏è Impossible de r√©parer l'URL (${step}):`, {
        incorrectUrl,
        availableUrls: this.originalVideos.map((v) => v.upload_url),
        videoId: videoId || "N/A",
      });
    }

    return incorrectUrl;
  }

  /**
   * Repair URLs in a Creatomate template
   * @param template The template from generateTemplate
   */
  repairTemplate(template: any): void {
    if (!template.elements || !Array.isArray(template.elements)) {
      return;
    }

    template.elements.forEach((composition: any, compIndex: number) => {
      if (composition.elements && Array.isArray(composition.elements)) {
        composition.elements.forEach((element: any, elemIndex: number) => {
          if (element.type === "video" && element.source) {
            // Here, we don't have a guaranteed videoId, so pattern matching is key
            const originalSource = element.source;
            element.source = this.repairUrl(
              originalSource,
              undefined,
              `generate_template_comp_${compIndex}_elem_${elemIndex}`
            );
          }
        });
      }
    });
  }

  /**
   * Validate that all URLs in the template are correct
   * @param template The template to validate
   * @throws Error if any invalid URLs are found
   */
  validateTemplate(template: any): void {
    const validUrls = new Set(this.originalVideos.map((v) => v.upload_url));
    const invalidUrls: string[] = [];

    template.elements?.forEach((composition: any, compIndex: number) => {
      composition.elements?.forEach((element: any, elemIndex: number) => {
        if (element.type === "video" && element.source) {
          if (!validUrls.has(element.source)) {
            invalidUrls.push(
              `comp_${compIndex}_elem_${elemIndex}: ${element.source}`
            );
          }
        }
      });
    });

    if (invalidUrls.length > 0) {
      throw new Error(
        `URLs invalides d√©tect√©es dans le template: ${invalidUrls.join(", ")}`
      );
    }

    console.log("‚úÖ Toutes les URLs du template sont valides");
  }

  /**
   * Get all corrections made during the repair process
   * @returns Array of correction objects
   */
  getCorrections() {
    return this.corrections;
  }

  /**
   * Get a summary of corrections made
   * @returns Summary object with counts and details
   */
  getRepairSummary() {
    const summary = {
      totalCorrections: this.corrections.length,
      byStep: {} as Record<string, number>,
      byMethod: {} as Record<string, number>,
    };

    this.corrections.forEach((correction) => {
      // Count by step
      if (!summary.byStep[correction.step]) {
        summary.byStep[correction.step] = 0;
      }
      summary.byStep[correction.step] =
        (summary.byStep[correction.step] || 0) + 1;

      // Count by method
      if (!summary.byMethod[correction.method]) {
        summary.byMethod[correction.method] = 0;
      }
      summary.byMethod[correction.method] =
        (summary.byMethod[correction.method] || 0) + 1;
    });

    return summary;
  }
}
